<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Wxcafé</title><link href="//wxcafe.net/" rel="alternate"></link><link href="//wxcafe.net/feeds/feed.ranting.xml" rel="self"></link><id>//wxcafe.net/</id><updated>2014-02-17T05:02:00+01:00</updated><entry><title>NAT</title><link href="//wxcafe.net/posts/nat/" rel="alternate"></link><updated>2014-02-17T05:02:00+01:00</updated><author><name>wxcafé</name></author><id>tag:wxcafe.net,2014-02-17:posts/nat/</id><summary type="html">&lt;p&gt;NAT (Network Address Translation) in a word?&lt;br /&gt;
It&amp;rsquo;s complicated. Very. Don&amp;rsquo;t do it, you&amp;rsquo;d damage your brain.  &lt;/p&gt;
&lt;p&gt;Bon, sinon, prochain article serieux vite, bisous.&lt;/p&gt;</summary></entry><entry><title>Pourquoi je vais quitter linux pour passer a FreeBSD.</title><link href="//wxcafe.net/posts/pourquoi-je-vais-quitter-linux-pour-passer-a-freebsd/" rel="alternate"></link><updated>2013-02-04T17:41:00+01:00</updated><author><name>Wxcafe</name></author><id>tag:wxcafe.net,2013-02-04:posts/pourquoi-je-vais-quitter-linux-pour-passer-a-freebsd/</id><summary type="html">&lt;p&gt;&lt;em&gt;This is subject to debate, and as most of the actors in this field are
not French-speaker, there is an English version of this text &lt;a href="http://data.wxcafe.net/archives/126"&gt;here&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Bon, voila. J&amp;rsquo;ai passé le cap. Je suis sous GNU/Linux depuis un certain
temps, maintenant, et depuis un certain temps je remarque des
changements malvenus. Bien entendu, au début, je n&amp;rsquo;avais pas les
connaissances nécessaires pour comprendre ne serait-ce que ces
modifications existaient. Et puis certaines sont arrivées avant que je
n&amp;rsquo;ai même idée que quelque chose dans mon système d&amp;rsquo;exploitation avait
cette fonction la. Par exemple, udev, ou policykit/consolekit/. A
l&amp;rsquo;époque, je n&amp;rsquo;avais aucune idée de la façon dont les disques étaient
montés sur mon système. Le premier système non-Windows que j&amp;rsquo;ai utilisé
fut Ubuntu 9.10 Karmic Koala, et il était encore trop tôt pour que je
cherche a démonter le système pour comprendre comment il fonctionnait en
profondeur. Cependant, avec le temps, les connaissances s&amp;rsquo;accumulant et
mon niveau de compréhension du système s&amp;rsquo;améliorant, j&amp;rsquo;ai commencé a
remarquer que certain bouts de l&amp;rsquo;OS ne collaient pas exactement avec les
autres. Bien sur, je ne saurais dire si cette réalisation s&amp;rsquo;est faite a
cause de la recrudescence de ces bouts d&amp;rsquo;OS, ou bien juste a cause de ma
compréhension plus poussée. Toujours est-il que ces petits bouts d&amp;rsquo;OS ne
s’adaptant pas au reste du système se faisaient de plus en plus visible.
Et puis, un jour, j&amp;rsquo;en ai eu marre de voir unity sur ma machine, et j&amp;rsquo;ai
choisi de passer a Archlinux. C&amp;rsquo;était avant le passage a systemd. Ce
système me convenait bien. Si je n&amp;rsquo;installais pas Gnome, ce que je ne
comptais pas faire, il ne me forçait pas a installer un *kit
quelconque, ni dbus. Oui, udev était toujours la, mais c&amp;rsquo;était le moins
envahissant de ceux la.&lt;/p&gt;
&lt;p&gt;Mais Archlinux est passé a systemd. Attention hein, je ne critique ici
ni systemd, ni udev, ni même les &lt;em&gt;kit, et surtout pas Archlinux. Les
premiers sont probablement très efficaces dans leur domaine, et le
second n&amp;rsquo;a pas &lt;strong&gt;vraiment&lt;/strong&gt; eu le choix, rapport a la philosophie de la
distribution d&amp;rsquo;avoir au plus vite les dernières versions de tout.
Cependant, systemd, tout comme udev et les &lt;/em&gt;kits (bien que ce ne soient
pas les seuls a faire ça&amp;hellip;) ont un problème très précis, qui n&amp;rsquo;importe
pas a tout le monde, mais qui est très gênant pour ceux a qui il
importe, et ce problème est que ces systèmes ne respectent absolument
pas la philosophie UNIX. La philosophie UNIX, pour rappel, se résume en
ces 9 principes :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ce qui est petit est beau&lt;/li&gt;
&lt;li&gt;Faites en sorte que chaque programme fasse une chose, bien.&lt;/li&gt;
&lt;li&gt;Faites un prototype aussi vite que possible&lt;/li&gt;
&lt;li&gt;Choisissez la portabilité plutôt que l&amp;rsquo;efficacité&lt;/li&gt;
&lt;li&gt;Stockez les données dans des fichiers textes.&lt;/li&gt;
&lt;li&gt;Utilisez ce qui existe déjà a votre avantage. [&lt;strong&gt;1&lt;/strong&gt;]&lt;/li&gt;
&lt;li&gt;Utilisez des scripts shells pour faciliter la portabilité et la
    réutilisation.&lt;/li&gt;
&lt;li&gt;Évitez les UI qui &amp;ldquo;capturent&amp;rdquo; l&amp;rsquo;utilisateur.&lt;/li&gt;
&lt;li&gt;Faites de chaque programme un filtre.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Alors bien entendu, un système d&amp;rsquo;exploitation est fait pour évoluer, et
on pourrait penser qu&amp;rsquo;UNIX a fait son temps. Cependant, ce n&amp;rsquo;est pas
exactement la façon dont l&amp;rsquo;informatique fonctionne. Effectivement, les
standards, les systèmes d&amp;rsquo;exploitation, les logiciels, tout doit évoluer
- ou mourir - et UNIX ne fait pas exception a la règle. Mais ce n&amp;rsquo;est
pas d&amp;rsquo;UNIX que nous parlons ici. C&amp;rsquo;est de la &lt;em&gt;philosophie&lt;/em&gt; UNIX. Et
celle-ci n&amp;rsquo;a pas fait son temps, &lt;strong&gt;elle a fait ses preuves.&lt;/strong&gt; La
philosophie UNIX, en plus d&amp;rsquo;être efficace sur le papier, a aussi 44 ans
de tests derrière elle, et fonctionne aussi bien qu&amp;rsquo;au premier jour.&lt;br /&gt;
La philosophie UNIX est aussi et surtout une garantie d&amp;rsquo;utilisabilité
et de simplicité pour les administrateurs systèmes, pour les
développeurs, bref pour tous ceux qui font de l&amp;rsquo;informatique&lt;em&gt;sérieusement&lt;/em&gt; (je ne dis pas que les autres métiers de l&amp;rsquo;informatique
ne sont pas sérieux, je prend juste ceux-ci comme exemples parce que ce
sont ceux qui sont les plus proches du système).&lt;/p&gt;
&lt;p&gt;Tous OS se doit d&amp;rsquo;avoir un système standardisé pour faire communiquer
les programmes entre eux. UNIX a un système de pipes, des sortes de
fichiers spéciaux permettant d&amp;rsquo;échanger des informations. C&amp;rsquo;est
efficace, ça respecte le &amp;ldquo;tout est fichier&amp;rdquo;, c&amp;rsquo;est standard, c&amp;rsquo;est
simple a comprendre, bref, ça fonctionne parfaitement. Dbus vient
remplacer ça, avec une interface qui n&amp;rsquo;est explicitement pas faite pour
être utilisée a la ligne de commande mais a l&amp;rsquo;aide d&amp;rsquo;APIs, et un
programme monolithique qui effectue sa tache d&amp;rsquo;une façon complètement
obscure pour l&amp;rsquo;utilisateur. Alors bien sur, il l&amp;rsquo;effectue d&amp;rsquo;une façon
efficace, cette tache. Oui, ça va plus vite qu&amp;rsquo;avant. Oui, c&amp;rsquo;est plus
&amp;ldquo;rangé&amp;rdquo;, ça fait moins &amp;ldquo;fouillis&amp;rdquo;. Mais c&amp;rsquo;est moins efficace. C&amp;rsquo;est&lt;em&gt;beaucoup&lt;/em&gt; moins utilisable pour l&amp;rsquo;utilisateur final. C&amp;rsquo;est
horriblement chiant pour les sysadmins, parce qu&amp;rsquo;ils ne peuvent plus
lire facilement les échanges entre programmes. C&amp;rsquo;est peu pratique, en
fin de compte. Et ça ne respecte pas du tout la philosophie UNIX.&lt;br /&gt;
Systemd prend le même parti de créer une interface unifiée, accessible
via des appels a des APIs uniquement, complètement obscure, extrêmement
abstraite, bien entendu monolithique, et très peu ouverte a la
modification par l&amp;rsquo;utilisateur final. Alors oui, il parait que ça
augmente la vitesse de boot. Eh bien, au risque d&amp;rsquo;en choquer quelques
uns, je préfère avoir un système qui boote &lt;em&gt;légèrement&lt;/em&gt; plus lentement
et que je puisse modifier facilement, et qui soit ouvert, compréhensible
et distribué. C&amp;rsquo;est presque comme si les projets freedesktop.org avaient
pour but de remplacer la base UNIX de linux en créant un système
concurrent, bâtard, bâti sur le kernel Linux mais n&amp;rsquo;employant plus les
systèmes basiques d&amp;rsquo;UNIX.&lt;/p&gt;
&lt;p&gt;Le problème est qu&amp;rsquo;il est facilement visible que la direction prise par
la communauté Linux n&amp;rsquo;est pas celle du retour sur les systèmes UNIX ni
celle du développement de solutions respectant la philosophie UNIX, mais
remises au gout du jour (?), mais est bien d&amp;rsquo;accepter et de pousser les
changements apportés par les projets freedesktop.org directement dans le
cœur du système lui même. Ainsi, Fedora (très près de Red Hat, dont font
partie de nombreux développeurs de ces projets), a déjà adopté tous ces
changements (archlinux aussi, mais pour d&amp;rsquo;autres raisons&amp;hellip;), et on peut
compter sur le fait que les autres distributions l&amp;rsquo;adopteront un jour ou
l&amp;rsquo;autre.&lt;/p&gt;
&lt;p&gt;Bon, maintenant que nous avons, si ce n&amp;rsquo;est démontré la nocivité de ces
systèmes, tout du moins exprimé les raisons qui font qu&amp;rsquo;ils me
déplaisent, on pourrait penser qu&amp;rsquo;il suffit de passer a une distribution
n&amp;rsquo;incluant pas systemd, voire a une distribution n&amp;rsquo;incluant pas du tout
de contenus freedesktop.org, et de vivre avec le fait de ne pas être sur
archlinux. Cependant, avec un peu de réflexion, on voit que si des
distributions comme archlinux et Fedora ont adopté systemd (et
qu&amp;rsquo;OpenSUSE est en train de l’intégrer), il est probable que cela
devienne un standard au fil des années, et que seuls survivent systemd
et upstart, le gestionnaire de démarrage d&amp;rsquo;ubuntu, qui ne changera
probablement pas (je les vois mal revenir en arrière sur ce point.)
Toujours est-il que l&amp;rsquo;init héritée du System V semble condamnée a mourir
sous Linux. Il pourrait être judicieux de passer sous debian squeeze,
qui ne recevra probablement jamais la mise a jour, ou a wheezy, qui ne
la recevra probablement que dans 2/3 ans. Cependant, cette période est
toujours trop courte, et met sur mon système d&amp;rsquo;exploitation une date
d&amp;rsquo;expiration, chose qui ne me plait que moyennement. Non, la solution
est de passer sous un système autre, qui ait son propre système d&amp;rsquo;init
(ou qui ne risque pas de passer sous systemd). Dans ce cas, deux options
principales s&amp;rsquo;ouvrent a moi: OpenSolaris et *BSD. Minix n&amp;rsquo;est pas
vraiment un choix, vu le peu de programmes qu&amp;rsquo;il permet de faire
fonctionner et le fait qu&amp;rsquo;il ne soit disponible que sur i386, ce qui
n&amp;rsquo;est pas vraiment avantageux au vu de mon système en x86_64. Haiku
n&amp;rsquo;est pas un choix non plus, puisque le but est de rester dans une
optique UNIX.&lt;/p&gt;
&lt;p&gt;OpenSolaris est un système d&amp;rsquo;exploitation tout a fait valable. Je n&amp;rsquo;ai
en théorie aucun problème sur cet OS, sauf que certains choix de design
ne correspondent pas du tout a l&amp;rsquo;idée que j&amp;rsquo;ai d&amp;rsquo;un OS. En effet,
OpenSolaris ressemble assez a Debian dans sa vision du fonctionnement de
ses outils, avec des paquets modifiés pour les rendre plus simples a
utiliser (fichiers de configuration fournis par défaut, par exemple, et
autres patchs &amp;ldquo;release-only&amp;rdquo;), et une tendance a faire des scripts et
des outils installés par défaut pour tout et n&amp;rsquo;importe quoi. Bref, cela
n&amp;rsquo;est pas le sujet. Il convient aussi de voir qu&amp;rsquo;avec la récente
acquisition de Sun par Oracle, il est possible que le projet OpenSolaris
n&amp;rsquo;ait pas de très beaux jours devant lui (la &lt;a href="http://hub.opensolaris.org/bin/view/Main/"&gt;page d’accueil&lt;/a&gt; du
projet affiche d&amp;rsquo;ailleurs un ÉNORME logo Oracle, du meilleur gout.)&lt;/p&gt;
&lt;p&gt;Il reste donc *BSD. Pourquoi choisir FreeBSD plutôt qu&amp;rsquo;OpenBSD, NetBSD
ou DragonFlyBSD (pour ne citer que les plus connus) ? Et bien c&amp;rsquo;est
simple : pour aucune raison particulière. OpenBSD et NetBSD ont pour
réputation d&amp;rsquo;être orientées sécurité, et d&amp;rsquo;après ce que j&amp;rsquo;ai pu en voir
DFBSD ressemble aussi au système de l&amp;rsquo;assistance a l&amp;rsquo;user a outrance
décris plus haut. Mais la vérité est que je n&amp;rsquo;ai pas fait suffisamment
de recherches et que FreeBSD ne va me voir arriver que par hasard, parce
qu&amp;rsquo;entre toutes les BSD ca me semble la plus sympa et la plus agréable a
utiliser, plus le fait que le système de ports me convient bien (j&amp;rsquo;aime
pouvoir configurer mes logiciels de façon assez profonde.)&lt;/p&gt;
&lt;p&gt;Voila, c&amp;rsquo;est mon avis sur ce &amp;ldquo;problème&amp;rdquo; actuel du monde de Linux. Bien
entendu, je continuerai a utiliser Linux, et je ne peux qu’espérer que
les systèmes tels que systemd ou dbus ne disparaissent, ou tout du moins
n&amp;rsquo;apparaissent jamais chez certaines distributions, créant de ce fait un
choix pour les utilisateurs.&lt;br /&gt;
[1]: Je n&amp;rsquo;ai pas trouvé de traduction satisfaisante a &amp;ldquo;software leveraging&amp;rdquo;, mais l&amp;rsquo;idée est la&amp;hellip;*&lt;/p&gt;</summary></entry><entry><title>Update et pensées a propos du Raspberry Pi</title><link href="//wxcafe.net/posts/update-et-pensees-a-propos-du-raspberry-pi/" rel="alternate"></link><updated>2013-01-27T01:55:00+01:00</updated><author><name>Wxcafe</name></author><id>tag:wxcafe.net,2013-01-27:posts/update-et-pensees-a-propos-du-raspberry-pi/</id><summary type="html">&lt;p&gt;Bon.&lt;br /&gt;
J&amp;rsquo;ai annoncé il y a environ 20 jours que j&amp;rsquo;avais pour projet de faire
une Piratebox basée sur un Raspberry Pi, &lt;del&gt;astucieusement&lt;/del&gt; nommée
PiRatBox. Il se trouve qu&amp;rsquo;après de nombreux essais, un problème
récurrent apparait: le Raspberry Pi n&amp;rsquo;est pas capable de fournir assez
de courant par défaut pour faire fonctionner a la fois un disque dur et
une antenne WiFi.&lt;br /&gt;
Alors, autant il me semble évident qu&amp;rsquo;avec une
alimentation provenant d&amp;rsquo;un port USB a 2A (max), je n&amp;rsquo;avais pas
énormément de chances d&amp;rsquo;avoir 2A sur chacun des ports host du Raspi,
autant avoir moins de 250 mA sur chacun de ces ports me semble un tout
petit peu exagéré en terme de rentabilité.  &lt;/p&gt;
&lt;p&gt;De même, le fait de ne pas pouvoir désactiver le port Ethernet (ne me
servant a rien) (vous savez, celui qui est monté en USB&amp;hellip;), qui
consomme énormément, est assez louche. Il devrait toujours être possible
de désactiver une device USB, me semble-t-il, au niveau logiciel. La,
bien qu&amp;rsquo;il soit surement possible de la désactiver au niveau du kernel,
il n&amp;rsquo;est pas &lt;strong&gt;simplement&lt;/strong&gt; possible de la &amp;ldquo;débrancher&amp;rdquo;. Ce qui est bien
chiant, étant donné le besoin évident de puissance électrique dans
lequel on se retrouve.  &lt;/p&gt;
&lt;p&gt;Bon, je dois avouer n&amp;rsquo;avoir pas testé de lancer les différents services
composant le système des piratebox sous arch, pour la simple &lt;del&gt;et
bonne&lt;/del&gt; raison qu&amp;rsquo;arch utilise systemd et qu&amp;rsquo;il n&amp;rsquo;existe pas de wrapper
systemd pour les daemons piratebox, et que j&amp;rsquo;ai la flemme d&amp;rsquo;en faire,
parce que systemd est une horreur a utiliser avec les scripts init. Donc
non, j&amp;rsquo;utiliserai debian. Le problème d&amp;rsquo;utiliser debian dans ce cas
précis est que apt/dpkg a une gestion des dépendances dans un sens mais
pas dans l&amp;rsquo;autre, en ce sens que si on installe un package &amp;ldquo;haut&amp;rdquo;, c&amp;rsquo;est
a dire dépendant de plusieurs autres packages, apt/dpkg se charge
efficacement d&amp;rsquo;installer toutes les dépendances nécessaires, tandis que
si on désinstalle un package &amp;ldquo;bas&amp;rdquo;, c&amp;rsquo;est a dire sur lequel de nombreux
autres packages dépendent, apt/dpkg ne désinstalle pas ces packages
&amp;ldquo;hauts&amp;rdquo;, ce qui pose un vrai problème quand on se retrouve sur un
Raspberry Pi, puisqu&amp;rsquo;il n&amp;rsquo;y a pas de moyen &amp;ldquo;facile&amp;rdquo; de choisir ce qui
sera installé sur le système avant l&amp;rsquo;installation proprement dite
(puisque le moyen &amp;ldquo;universel&amp;rdquo; d&amp;rsquo;installation sur Raspberry Pi est le dd
vers la SD qui sert de disque système.)&lt;/p&gt;
&lt;p&gt;Il y a &lt;strong&gt;énormément&lt;/strong&gt; d&amp;rsquo;autres critiques que l&amp;rsquo;ont pourrait faire
concernant le Raspberry Pi. Son système de démarrage a s&amp;rsquo;arracher les
cheveux, par exemple. En effet, plutôt que de faire comme tout pc
normalement constitué ou la partie calcul démarre, lance le bootloader,
cherche le kernel de l&amp;rsquo;OS qui lui même se lance, initialise le hardware,
etc&amp;hellip;, a un système bâtard du au fait que la puce au centre de la carte
est a la base une puce graphique a laquelle on a greffé un cœur de
calcul (probablement au fond d&amp;rsquo;une cour d&amp;rsquo;immeuble, dans les quartiers
pauvres de Bratislava, vu la propreté de la greffe&amp;hellip;), et le moyen le
plus efficace qu&amp;rsquo;aient trouvé les personnes ayant implémenté cette
atrocité de gérer le boot est donc de faire démarrer le cœur graphique
en premier, ce dernier exécute un code propriétaire pour démarrer le
cœur de calcul, qui a son tour lance le bootloader qui cherche le kernel
etc&amp;hellip;  &lt;/p&gt;
&lt;p&gt;Ce qui non seulement complique énormément le boot, non seulement ajoute
du code propriétaire a un projet se disant libre, mais en plus n&amp;rsquo;est&lt;strong&gt;visiblement&lt;/strong&gt; pas fait pour être utilisé de cette manière. Le hack,
oui, mais uniquement quand c&amp;rsquo;est bien réalisé, sinon je dis non.  &lt;/p&gt;
&lt;p&gt;Enfin, le projet que j&amp;rsquo;avais est toujours en cours de réalisation. Je
le terminerai dès que j&amp;rsquo;aurai récupéré les outils nécessaires pour
monter mon alimentation personnalisée pour le Raspberry Pi. Et une fois
que cela sera fait, ce Raspi restera une Piratebox pour le reste de sa
vie. Les problèmes qu&amp;rsquo;il m&amp;rsquo;a posé, qu&amp;rsquo;il n&amp;rsquo;aurait pas du me poser, m&amp;rsquo;ont
trop agacé pour que j&amp;rsquo;aie envie de le sortir et de jouer avec une fois
sa mission remplie.  &lt;/p&gt;
&lt;p&gt;Dommage.&lt;/p&gt;</summary></entry></feed>